# Hopcroft-Karp bipartite max-cardinality matching and max independent set
# David Eppstein, UC Irvine, 27 Apr 2002

def bipartiteMatch(graph):
    '''Find maximum cardinality matching of a bipartite graph (U,V,E).
    The input format is a dictionary mapping members of U to a list
    of their neighbors in V.  The output is a triple (M,A,B) where M is a
    dictionary mapping members of V to their matches in U, A is the part
    of the maximum independent set in U, and B is the part of the MIS in V.
    The same object may occur in both U and V, and is treated as two
    distinct vertices if this happens.'''

    # initialize greedy matching (redundant, but faster than full search)
    matching = {}
    for u in graph:
        for v in graph[u]:
            if v not in matching:
                matching[v] = u
                break

    while 1:
        # structure residual graph into layers
        # pred[u] gives the neighbor in the previous layer for u in U
        # preds[v] gives a list of neighbors in the previous layer for v in V
        # unmatched gives a list of unmatched vertices in final layer of V,
        # and is also used as a flag value for pred[u] when u is in the first layer
        preds = {}
        unmatched = []
        pred = dict([(u,unmatched) for u in graph])
        for v in matching:
            del pred[matching[v]]
        layer = list(pred)

        # repeatedly extend layering structure by another pair of layers
        while layer and not unmatched:
            newLayer = {}
            for u in layer:
                for v in graph[u]:
                    if v not in preds:
                        newLayer.setdefault(v,[]).append(u)
            layer = []
            for v in newLayer:
                preds[v] = newLayer[v]
                if v in matching:
                    layer.append(matching[v])
                    pred[matching[v]] = v
                else:
                    unmatched.append(v)

        # did we finish layering without finding any alternating paths?
        if not unmatched:
            unlayered = {}
            for u in graph:
                for v in graph[u]:
                    if v not in preds:
                        unlayered[v] = None
            return (matching,list(pred),list(unlayered))

        # recursively search backward through layers to find alternating paths
        # recursion returns true if found path, false otherwise
        def recurse(v):
            if v in preds:
                L = preds[v]
                del preds[v]
                for u in L:
                    if u in pred:
                        pu = pred[u]
                        del pred[u]
                        if pu is unmatched or recurse(pu):
                            matching[v] = u
                            return 1
            return 0

        for v in unmatched: recurse(v)





def trivially_schedulable():
    '''Do a toy example to demo the algorithm
       Let's pretend we have to schedule a single day.
    '''

    # There are 24 one hour slots in the day.
    slots = range(0,24)

    # An RCS observation can go in any slot
    rcs_slots = range(1,25)

    # A Hawaii observation can only go in the early evening
    hawaii_slots = range(18,22)

    # A UK schools slot can only go in the daytime
    uk_slots = range(9,17)


    # We need to schedule 5 rcs slots, 3 hawaii slots, and 6 uk schools
    # I do this explicitly here for clarity, but this could be generated by loop

    constraint_graph = {
                         'rcs1' : rcs_slots,
                         'rcs2' : rcs_slots,
                         'rcs3' : rcs_slots,
                         'rcs4' : rcs_slots,
                         'rcs5' : rcs_slots,
                         'hw1'  : hawaii_slots,
                         'hw2'  : hawaii_slots,
                         'hw3'  : hawaii_slots,
                         'uk1'  : uk_slots,
                         'uk2'  : uk_slots,
                         'uk3'  : uk_slots,
                         'uk4'  : uk_slots,
                         'uk5'  : uk_slots,
                         'uk6'  : uk_slots,
                        }


    # Find an optimal matching!
    output = bipartiteMatch(constraint_graph)
    matching = output[0]

    print matching

    print "Time => Slot type"
    for key, value in matching.iteritems():
        print key, '   => ', value




def cant_please_everyone():
    '''Do a toy example to demo the algorithm
       Let's pretend we have to schedule a single day.
    '''

    # There are 24 one hour slots in the day.
    slots = range(0,24)

    # An RCS observation can go in any slot
    rcs_slots = range(18,22)

    # Hawaii and schools directly clash
    hawaii_slots = range(19,21)

    uk_slots = range(22,24)


    # We need to schedule 2 rcs slots, 2 hawaii slots, and 1 uk schools
    # I do this explicitly here for clarity, but this could be generated by loop

    constraint_graph = {
                         'rcs1' : rcs_slots,
                         'rcs2' : rcs_slots,
                         'hw1'  : hawaii_slots,
                         'hw2'  : hawaii_slots,
                         'uk1'  : uk_slots,
                        }


    # Find an optimal matching!
    output = bipartiteMatch(constraint_graph)
    matching = output[0]

    print matching

    print "Time => Slot type"
    for key, value in matching.iteritems():
        print key, '   => ', value


if __name__ == '__main__':
    cant_please_everyone()
